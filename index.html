<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Dots & Dice (Visual Update)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    /* BASIC SETUP & BACKGROUND IMAGE */
    body, html { 
      height: 100%; margin: 0; 
      /* GAME BACKGROUND IMAGE HERE */
      background: url('https://cdn.discordapp.com/attachments/1420003318096461825/1465701832948060356/att.3CUk4_pCKFMmxIuacZHQ3djMXO55ZSYpGbEwLgnd-7s.jpg?ex=697a10b4&is=6978bf34&hm=e2d37a26291db6fcbf7a153f5250cab31ee8d4c5a8f6e9fa25f2cab1efe569e4&') no-repeat center center fixed; 
      background-size: cover;
      font-family: 'Segoe UI', sans-serif; overflow: hidden; overscroll-behavior: none; 
    }
    
    /* GAME CANVAS - Made transparent so background shows through */
    #game-container { 
      width: 100%; height: 100%; position: absolute; top: 0; left: 0; 
      z-index: 1; touch-action: none; background: rgba(255, 255, 255, 0.1); 
    }
    
    /* UI PANELS */
    .ui-panel {
      position: absolute; background: rgba(255, 255, 255, 0.95); border-radius: 16px; padding: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3); z-index: 1000; text-align: center;
      width: 85%; max-width: 350px; left: 50%; top: 50%; transform: translate(-50%, -50%);
      backdrop-filter: blur(5px);
    }

    /* --- 3D DICE CSS --- */
    #dice-scene {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.7); z-index: 3000;
      display: none; align-items: center; justify-content: center;
      perspective: 1000px;
    }
    .cube {
      width: 100px; height: 100px; position: relative;
      transform-style: preserve-3d; transform: translateZ(-50px);
      transition: transform 1s ease-out;
    }
    .cube.rolling { animation: spinDice 0.8s linear infinite; }
    
    /* DICE FACE TEXTURE */
    .face {
      position: absolute; width: 100px; height: 100px;
      /* DICE TEXTURE IMAGE HERE */
      background-image: url('https://img.freepik.com/free-photo/white-marble-texture-background_1253-29.jpg');
      background-size: cover;
      border: 1px solid #999; border-radius: 12px;
      display: flex; align-items: center; justify-content: center;
      box-shadow: inset 0 0 15px rgba(0,0,0,0.2);
    }
    .face.front  { transform: rotateY(0deg) translateZ(50px); }
    .face.back   { transform: rotateY(180deg) translateZ(50px); }
    .face.right  { transform: rotateY(90deg) translateZ(50px); }
    .face.left   { transform: rotateY(-90deg) translateZ(50px); }
    .face.top    { transform: rotateX(90deg) translateZ(50px); }
    .face.bottom { transform: rotateX(-90deg) translateZ(50px); }
    .dot-grid { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); width: 70%; height: 70%; }
    /* Darker dots for better contrast on texture */
    .d-dot { background: #222; border-radius: 50%; width: 12px; height: 12px; margin: auto; box-shadow: 1px 1px 2px rgba(255,255,255,0.5); }
    
    @keyframes spinDice {
      0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
      100% { transform: rotateX(720deg) rotateY(360deg) rotateZ(360deg); }
    }
    .show-1 { transform: rotateX(0deg) rotateY(0deg); }
    .show-6 { transform: rotateX(180deg) rotateY(0deg); }
    .show-2 { transform: rotateY(-90deg); }
    .show-5 { transform: rotateY(90deg); }
    .show-3 { transform: rotateX(-90deg); }
    .show-4 { transform: rotateX(90deg); }

    /* BARS */
    .top-bar { position: absolute; top: 0; left: 0; right: 0; height: 80px; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(4px); display: flex; align-items: center; justify-content: space-between; padding: 0 10px; z-index: 500; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    .bottom-bar { position: absolute; bottom: 0; left: 0; right: 0; height: 90px; background: rgba(255, 255, 255, 0.95); display: flex; align-items: center; justify-content: space-around; z-index: 500; padding-bottom: env(safe-area-inset-bottom); border-top: 1px solid #ddd; }

    /* CONTROLS */
    input, select { padding: 12px; margin: 8px 0; width: 90%; border: 2px solid #eee; border-radius: 8px; font-size: 16px; outline: none; }
    button { padding: 12px 20px; margin: 8px 0; background: #2f7bff; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; width: 100%; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
    button:active { transform: scale(0.96); }
    button:disabled { background: #ccc; opacity: 0.7; cursor: not-allowed; box-shadow: none; }
    .hidden { display: none !important; }
    
    /* OVERLAYS */
    #waitingOverlay, #gameOverOverlay {
      position: absolute; top:0; left:0; width:100%; height:100%;
      background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); color: white; z-index: 2000; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center;
    }
    .score-item { display: flex; flex-direction: column; align-items: center; margin: 0 5px; font-weight: bold; font-size: 14px; text-shadow: 0 1px 2px white; }
    .score-dot { width: 12px; height: 12px; border-radius: 50%; margin-bottom: 2px; border: 1px solid rgba(0,0,0,0.2); }
  </style>
</head>
<body>

  <div id="dice-scene">
    <div class="cube" id="diceCube">
      <div class="face front"><div class="dot-grid"><div style="grid-area:2/2" class="d-dot"></div></div></div>
      <div class="face back"><div class="dot-grid"><div style="grid-area:1/1" class="d-dot"></div><div style="grid-area:1/3" class="d-dot"></div><div style="grid-area:2/1" class="d-dot"></div><div style="grid-area:2/3" class="d-dot"></div><div style="grid-area:3/1" class="d-dot"></div><div style="grid-area:3/3" class="d-dot"></div></div></div>
      <div class="face right"><div class="dot-grid"><div style="grid-area:1/3" class="d-dot"></div><div style="grid-area:3/1" class="d-dot"></div></div></div>
      <div class="face left"><div class="dot-grid"><div style="grid-area:1/1" class="d-dot"></div><div style="grid-area:1/3" class="d-dot"></div><div style="grid-area:2/2" class="d-dot"></div><div style="grid-area:3/1" class="d-dot"></div><div style="grid-area:3/3" class="d-dot"></div></div></div>
      <div class="face top"><div class="dot-grid"><div style="grid-area:1/1" class="d-dot"></div><div style="grid-area:2/2" class="d-dot"></div><div style="grid-area:3/3" class="d-dot"></div></div></div>
      <div class="face bottom"><div class="dot-grid"><div style="grid-area:1/1" class="d-dot"></div><div style="grid-area:1/3" class="d-dot"></div><div style="grid-area:3/1" class="d-dot"></div><div style="grid-area:3/3" class="d-dot"></div></div></div>
    </div>
  </div>
  
  <div id="game-container"></div>

  <div id="waitingOverlay" class="hidden">
    <h2>Room Ready!</h2>
    <p>Room Code:</p>
    <h1 id="shareCode" style="font-size: 50px; color: #4eff4e; margin: 5px 0;">---</h1>
    <p id="waitText">Waiting for players...</p>
    <div id="playerListDisplay" style="margin: 10px 0; color: #ddd; font-size: 14px;"></div>
    <button id="cancelWaitBtn" style="width: auto; background: #555; margin-top: 20px;">Exit Room</button>
  </div>

  <div id="gameOverOverlay" class="hidden">
    <h1 style="color: #ffd700; font-size: 40px; margin-bottom: 10px;">GAME OVER</h1>
    <h2 id="winnerText">Winner: ---</h2>
    <div id="finalScores" style="margin: 20px 0; font-size: 18px; line-height: 1.6;"></div>
    <button id="playAgainBtn" style="width: 200px; background: #28a745; display: none;">PLAY AGAIN</button>
    <button id="leaveGameBtn" style="width: 200px; background: #dc3545; margin-top: 10px;">LEAVE ROOM</button>
    <p id="hostMsg" style="font-size: 12px; color: #aaa; margin-top: 10px;">(Only Host can restart)</p>
  </div>

  <div id="lobbyUI" class="ui-panel">
    <h2 style="color:#2f7bff; margin-top:0;">Dots & Dice</h2>
    <input id="displayName" placeholder="Enter Nickname" maxlength="10" />
    <input id="roomInput" placeholder="Room Code (e.g. 1001)" maxlength="6" style="text-align: center; font-weight: bold; letter-spacing: 2px;"/>
    
    <div style="margin: 10px 0; text-align: left; padding: 0 5%;">
      <label style="font-size: 12px; color: #666; font-weight:bold;">GAME MODE:</label>
      <select id="gameMode">
        <option value="classic">Classic (Normal)</option>
        <option value="lucky" selected>Lucky Mode (Mystery)</option>
      </select>
    </div>

    <div style="margin: 10px 0; text-align: left; padding: 0 5%;">
      <label style="font-size: 12px; color: #666; font-weight:bold;">PLAYERS:</label>
      <select id="maxPlayers">
        <option value="2" selected>2 Players</option>
        <option value="3">3 Players</option>
        <option value="4">4 Players</option>
      </select>
    </div>

    <div style="margin: 10px 0; text-align: left; padding: 0 5%;">
      <label style="font-size: 12px; color: #666; font-weight:bold;">GRID SIZE:</label>
      <select id="gridSize">
        <option value="3">3 x 3 (Small)</option>
        <option value="4" selected>4 x 4 (Classic)</option>
        <option value="5">5 x 5 (Medium)</option>
        <option value="auto">Auto (Screen Fit)</option>
      </select>
    </div>

    <button id="createRoomBtn">CREATE ROOM</button>
    <div style="margin: 10px 0; color: #aaa; font-size: 12px;">â€” OR â€”</div>
    <button id="joinRoomBtn" style="background: #28a745;">JOIN ROOM</button>
  </div>

  <div id="gameUI_Top" class="top-bar hidden">
    <div style="min-width: 50px;">
      <div style="font-size:10px; color:#888;">ROOM</div>
      <div id="roomLabel" style="font-weight:bold; font-size:16px;">---</div>
    </div>
    <div style="flex-grow: 1; text-align: center; margin: 0 10px;">
        <span id="turnLabel" style="padding: 6px 12px; border-radius: 20px; font-size: 13px; font-weight:bold; background:#eee; display: inline-block; white-space: nowrap;">Connecting...</span>
    </div>
    <div id="scoreContainer" style="display:flex; gap:8px;"></div>
  </div>

  <div id="gameUI_Bottom" class="bottom-bar hidden">
    <button id="rollBtn" style="width: 60%; height: 50px; font-size: 18px;">ROLL DICE</button>
    <div style="text-align:center; margin-left: 10px;">
       <div style="font-size:10px; color:#666; font-weight:bold;">LINES</div>
       <b id="linesLeft" style="font-size:24px; color:#333;">0</b>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

  <script>
  // --- VISUAL ASSETS (BOX PHOTOS) ---
  // Using generic pattern textures for player boxes
  const BOX_IMAGES = {
    p0: 'https://img.freepik.com/free-vector/red-geometric-pattern-background_53876-113948.jpg', // Red Player
    p1: 'https://img.freepik.com/free-vector/blue-geometric-pattern-background_53876-113949.jpg', // Blue Player
    p2: 'https://img.freepik.com/free-vector/green-geometric-pattern-background_53876-113950.jpg', // Green Player
    p3: 'https://img.freepik.com/free-vector/orange-geometric-pattern-background_53876-113951.jpg'  // Orange Player
  };

  const FIREBASE_CONFIG = {
    apiKey: "AIzaSyCwy91uqMBAM_kXfxd8bE6LsVOXdNL54i8",
    authDomain: "dotgame-4a8df.firebaseapp.com",
    databaseURL: "https://dotgame-4a8df-default-rtdb.firebaseio.com",
    projectId: "dotgame-4a8df",
    storageBucket: "dotgame-4a8df.firebasestorage.app",
    messagingSenderId: "420421686536",
    appId: "1:420421686536:web:ac66a3a4a75aff31c908bd"
  };

  const PLAYER_CONFIG = [
    { id: 'p0', color: 'red', hex: 0xff4444, css: '#ff4444' },
    { id: 'p1', color: 'blue', hex: 0x2f7bff, css: '#2f7bff' },
    { id: 'p2', color: 'green', hex: 0x00cc00, css: '#00cc00' },
    { id: 'p3', color: 'orange', hex: 0xffbb00, css: '#ffbb00' }
  ];

  firebase.initializeApp(FIREBASE_CONFIG);
  const db = firebase.database();
  const auth = firebase.auth();
  let myUid = null;
  const savedName = localStorage.getItem('dotsDiceName');
  if(savedName) document.getElementById('displayName').value = savedName;

  auth.signInAnonymously().then(u => { myUid = u.user.uid; }).catch(e => alert("Net Error"));

  // SOUND ASSETS
  const sndRoll = new Audio('https://cdn.discordapp.com/attachments/1420003318096461825/1459851313398546472/dice-roll-sound.mp3?ex=6977e5bb&is=6976943b&hm=d2563b186124971b775524a0558746d877e9bb2bf20eab3804b89f03a2dde8af&');
  const sndLine = new Audio('https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3');
  const sndBoom = new Audio('https://cdn.discordapp.com/attachments/1420003318096461825/1458766850161905675/myinstants_2.mp3?ex=6977e83f&is=697696bf&hm=b9f8a9efd0791eda0dacc675a993af419f3a82804bde4e7df7770fa1cf37e64f&'); 
  const sndLucky = new Audio('https://assets.mixkit.co/active_storage/sfx/2019/2019-preview.mp3'); 

  let currentRoom = null;
  let roomData = null;
  let gameInstance = null;
  let autoDeleteInterval = null;
  let lastProcessedRoll = 0;
  let isRollingAnim = false; 

  // --- CREATE ROOM ---
  document.getElementById('createRoomBtn').onclick = async () => {
    if(!myUid) return alert("Connecting...");
    const code = document.getElementById('roomInput').value.trim().toUpperCase();
    const name = document.getElementById('displayName').value.trim() || 'Host';
    const sizeVal = document.getElementById('gridSize').value;
    const maxP = parseInt(document.getElementById('maxPlayers').value);
    const mode = document.getElementById('gameMode').value;
    
    if(!code) return alert("Enter Room Code");
    localStorage.setItem('dotsDiceName', name);

    const snap = await db.ref('rooms/' + code).once('value');
    if(snap.exists() && Date.now() - (snap.val().lastActive||0) < 600000) return alert("Code taken!");

    let rows, cols;
    if(sizeVal === 'auto') {
      const safeW = window.innerWidth - 40; const safeH = window.innerHeight - 180;
      cols = Math.min(Math.floor(safeW / 55), 10);
      rows = Math.min(Math.floor(safeH / 55), 12);
    } else { rows = cols = parseInt(sizeVal); }

    let specialBoxes = {};
    if(mode === 'lucky') {
      const allCoords = [];
      for(let r=0; r<rows; r++) for(let c=0; c<cols; c++) allCoords.push(`${r}_${c}`);
      for (let i = allCoords.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allCoords[i], allCoords[j]] = [allCoords[j], allCoords[i]];
      }
      if(allCoords.length >= 3) {
        specialBoxes[allCoords[0]] = 'bonus'; 
        specialBoxes[allCoords[1]] = 'bonus'; 
        specialBoxes[allCoords[2]] = 'boom';  
      }
    }

    await db.ref('rooms/' + code).set({
      config: { maxPlayers: maxP, rows, cols, mode },
      players: { [myUid]: { name, colorIdx: 0, score: 0 } },
      state: 'waiting',
      lastActive: Date.now(),
      turnOrder: [],
      turnIndex: 0,
      dice: { val: 0, rem: 0 },
      latestRoll: { val: 0, ts: 0 },
      filledBoxes: 0,
      totalBoxes: rows * cols,
      edges: {}, boxes: {},
      specialBoxes: specialBoxes
    });
    enterRoom(code, true);
  };

  // --- JOIN ROOM ---
  document.getElementById('joinRoomBtn').onclick = async () => {
    if(!myUid) return alert("Connecting...");
    const code = document.getElementById('roomInput').value.trim().toUpperCase();
    const name = document.getElementById('displayName').value.trim() || 'Player';
    if(!code) return alert("Enter Room Code");
    localStorage.setItem('dotsDiceName', name);

    const roomRef = db.ref('rooms/' + code);
    const snap = await roomRef.once('value');
    if(!snap.exists()) return alert("Room not found!");
    const r = snap.val();

    const pCount = Object.keys(r.players || {}).length;
    if(r.players && !r.players[myUid] && pCount >= r.config.maxPlayers) return alert("Room is Full!");

    const colorIdx = r.players[myUid] ? r.players[myUid].colorIdx : pCount;
    await roomRef.child('players/' + myUid).update({ name, colorIdx, score: 0 });
    
    const newSnap = await roomRef.once('value');
    const newR = newSnap.val();
    if(newR.state === 'waiting' && Object.keys(newR.players).length >= newR.config.maxPlayers) {
      const pIds = Object.keys(newR.players);
      for (let i = pIds.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pIds[i], pIds[j]] = [pIds[j], pIds[i]];
      }
      await roomRef.update({ state: 'playing', turnOrder: pIds, turnIndex: 0, lastActive: Date.now() });
    } else {
      await roomRef.update({ lastActive: Date.now() });
    }
    enterRoom(code, false);
  };

  document.getElementById('cancelWaitBtn').onclick = () => location.reload();
  document.getElementById('leaveGameBtn').onclick = () => location.reload();
  
  document.getElementById('playAgainBtn').onclick = () => {
    if(!currentRoom) return;
    db.ref(`rooms/${currentRoom}`).transaction(r => {
      if(!r) return r;
      r.state = 'playing';
      r.edges = {}; r.boxes = {}; r.filledBoxes = 0;
      r.dice = { val: 0, rem: 0 };
      r.latestRoll = { val: 0, ts: 0 };
      const pIds = Object.keys(r.players);
      for (let i = pIds.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pIds[i], pIds[j]] = [pIds[j], pIds[i]];
      }
      r.turnOrder = pIds; r.turnIndex = 0;
      Object.keys(r.players).forEach(uid => { r.players[uid].score = 0; });
      
      if(r.config.mode === 'lucky') {
        const allCoords = [];
        for(let row=0; row<r.config.rows; row++) for(let col=0; col<r.config.cols; col++) allCoords.push(`${row}_${col}`);
        for (let i = allCoords.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allCoords[i], allCoords[j]] = [allCoords[j], allCoords[i]];
        }
        r.specialBoxes = {};
        if(allCoords.length >= 3) {
            r.specialBoxes[allCoords[0]] = 'bonus';
            r.specialBoxes[allCoords[1]] = 'bonus';
            r.specialBoxes[allCoords[2]] = 'boom';
        }
      }
      return r;
    });
  };

  function enterRoom(code, isHost) {
    currentRoom = code;
    document.getElementById('lobbyUI').classList.add('hidden');
    document.getElementById('roomLabel').innerText = code;
    document.getElementById('waitingOverlay').classList.remove('hidden');
    if(isHost) document.getElementById('shareCode').innerText = code;
    else { document.getElementById('waitText').innerText = "Connecting..."; document.getElementById('shareCode').innerText = code; }

    if(isHost) autoDeleteInterval = setInterval(() => { db.ref(`rooms/${currentRoom}`).update({ lastActive: Date.now() }); }, 30000);

    if(!gameInstance) initPhaser();

    db.ref('rooms/' + code).on('value', snap => {
      roomData = snap.val();
      if(!roomData) { alert("Room closed."); location.reload(); return; }
      
      if(roomData.latestRoll && roomData.latestRoll.ts > lastProcessedRoll) {
        lastProcessedRoll = roomData.latestRoll.ts;
        isRollingAnim = true;
        trigger3DDice(roomData.latestRoll.val, () => {
          isRollingAnim = false;
          updateHTML_UI();
        });
        updateHTML_UI();
      } else {
        updateHTML_UI();
      }

      if(gameInstance) {
        const scene = gameInstance.scene.getScene('GameScene');
        if(scene) scene.drawBoard();
      }
    });
  }

  function trigger3DDice(finalVal, callback) {
    const scene = document.getElementById('dice-scene');
    const cube = document.getElementById('diceCube');
    scene.style.display = 'flex';
    
    sndRoll.currentTime = 0; 
    sndRoll.play().catch(() => {});

    cube.className = 'cube rolling';
    
    setTimeout(() => {
      cube.classList.remove('rolling');
      void cube.offsetWidth;
      cube.className = `cube show-${finalVal}`;
      
      setTimeout(() => { 
        scene.style.display = 'none'; 
        if(callback) callback();
      }, 1200);
    }, 800);
  }

  function updateHTML_UI() {
    const players = roomData.players || {};
    const waitOverlay = document.getElementById('waitingOverlay');
    if(roomData.state === 'waiting') {
      waitOverlay.classList.remove('hidden');
      document.getElementById('waitText').innerText = `Waiting: ${Object.keys(players).length} / ${roomData.config.maxPlayers} Players`;
      document.getElementById('playerListDisplay').innerHTML = Object.values(players).map(p => `<span style="color:${PLAYER_CONFIG[p.colorIdx].css}">${p.name}</span>`).join(', ');
    } else {
      waitOverlay.classList.add('hidden');
      document.getElementById('gameUI_Top').classList.remove('hidden');
      document.getElementById('gameUI_Bottom').classList.remove('hidden');
    }

    if(roomData.state === 'finished') {
      document.getElementById('gameOverOverlay').classList.remove('hidden');
      document.getElementById('gameUI_Bottom').classList.add('hidden');
      let maxScore = -999; let winners = [];
      Object.values(players).forEach(p => { if(p.score > maxScore) { maxScore = p.score; winners = [p]; } else if(p.score === maxScore) { winners.push(p); } });
      const wEl = document.getElementById('winnerText');
      wEl.innerText = `Winner: ${winners.map(p => p.name).join(' & ')}`;
      wEl.style.color = PLAYER_CONFIG[winners[0].colorIdx].css;
      let html = "";
      Object.values(players).forEach(p => { html += `<div style="color:${PLAYER_CONFIG[p.colorIdx].css}">${p.name}: ${p.score}</div>`; });
      document.getElementById('finalScores').innerHTML = html;
      
      const isHost = (roomData.turnOrder && roomData.turnOrder[0] === myUid);
      document.getElementById('playAgainBtn').style.display = isHost ? 'inline-block' : 'none';
      document.getElementById('hostMsg').style.display = isHost ? 'none' : 'block';
    } else { document.getElementById('gameOverOverlay').classList.add('hidden'); }

    const scoreCont = document.getElementById('scoreContainer');
    scoreCont.innerHTML = '';
    Object.values(players).forEach(p => {
      scoreCont.innerHTML += `<div class="score-item" style="color:${PLAYER_CONFIG[p.colorIdx].css}"><div class="score-dot" style="background:${PLAYER_CONFIG[p.colorIdx].css}"></div><span>${p.score}</span></div>`;
    });
    
    const linesEl = document.getElementById('linesLeft');
    if(isRollingAnim) {
        linesEl.innerText = "...";
    } else {
        linesEl.innerText = roomData.dice.rem;
    }

    if(roomData.state === 'playing') {
      const turnUid = roomData.turnOrder[roomData.turnIndex];
      const isMe = (turnUid === myUid);
      const turnLabel = document.getElementById('turnLabel');
      const rollBtn = document.getElementById('rollBtn');
      if(isMe) {
        turnLabel.innerText = "YOUR TURN"; turnLabel.style.background = PLAYER_CONFIG[players[turnUid].colorIdx].css; turnLabel.style.color = "white";
        if(roomData.dice.rem > 0 || isRollingAnim) { 
            rollBtn.innerText = isRollingAnim ? "ROLLING..." : "DRAW LINES"; 
            rollBtn.disabled = true; 
            rollBtn.style.opacity = isRollingAnim ? "0.5" : "1"; 
        } else { 
            rollBtn.innerText = "ROLL DICE"; 
            rollBtn.disabled = false; 
        }
      } else {
        turnLabel.innerText = `${players[turnUid].name}'s Turn`; turnLabel.style.background = "white"; turnLabel.style.color = PLAYER_CONFIG[players[turnUid].colorIdx].css; turnLabel.style.border = `2px solid ${PLAYER_CONFIG[players[turnUid].colorIdx].css}`;
        rollBtn.innerText = "WAITING..."; rollBtn.disabled = true;
      }
    }
  }

  document.getElementById('rollBtn').onclick = () => {
    if(!roomData || roomData.state !== 'playing') return;
    const turnUid = roomData.turnOrder[roomData.turnIndex];
    if(turnUid !== myUid || roomData.dice.rem > 0) return;
    
    sndRoll.play().catch(()=>{}); 
    sndBoom.play().then(()=>{ sndBoom.pause(); sndBoom.currentTime=0; }).catch(()=>{});
    sndLucky.play().then(()=>{ sndLucky.pause(); sndLucky.currentTime=0; }).catch(()=>{});

    const finalVal = Math.floor(Math.random() * 6) + 1;
    db.ref(`rooms/${currentRoom}`).update({ dice: { val: finalVal, rem: finalVal }, latestRoll: { val: finalVal, ts: Date.now() }, lastActive: Date.now() });
  };

  function initPhaser() {
    gameInstance = new Phaser.Game({ type: Phaser.AUTO, parent: 'game-container', width: window.innerWidth, height: window.innerHeight, transparent: true, scale: { mode: Phaser.Scale.RESIZE }, scene: GameScene });
  }

  class GameScene extends Phaser.Scene {
    constructor() { super('GameScene'); }

    preload() {
        // Load textures for the boxes (Player Avatars/Patterns)
        this.load.image('p0_tex', BOX_IMAGES.p0);
        this.load.image('p1_tex', BOX_IMAGES.p1);
        this.load.image('p2_tex', BOX_IMAGES.p2);
        this.load.image('p3_tex', BOX_IMAGES.p3);
    }

    create() {
      this.graphics = this.add.graphics();
      this.clickZones = [];
      this.specialIcons = [];
      this.boxImages = []; // Array to track box images
      this.events.on('updateBoard', this.drawBoard, this);
      this.scale.on('resize', this.drawBoard, this);
      this.time.delayedCall(500, () => this.drawBoard());
    }

    drawBoard() {
      if(!roomData || !roomData.config) return;
      
      // Cleanup previous render
      this.graphics.clear();
      this.clickZones.forEach(z => z.destroy()); this.clickZones = [];
      this.specialIcons.forEach(i => i.destroy()); this.specialIcons = [];
      this.boxImages.forEach(img => img.destroy()); this.boxImages = [];

      const { rows, cols } = roomData.config;
      const width = this.scale.width; const height = this.scale.height;
      const topPad = 85; const botPad = 100;
      const cellSize = Math.min((width-30)/cols, (height-(topPad+botPad))/rows);
      const dotRadius = Math.max(3, cellSize * 0.08);
      const lineThick = Math.max(3, cellSize * 0.07);
      const offsetX = (width - (cols * cellSize)) / 2;
      const offsetY = topPad + (height-(topPad+botPad) - (rows * cellSize)) / 2;

      const edges = roomData.edges || {};
      const boxes = roomData.boxes || {};
      const specials = roomData.specialBoxes || {};

      // Draw Boxes (IMAGES now instead of just fillRect)
      for(let r=0; r<rows; r++) {
        for(let c=0; c<cols; c++) {
          const key = `${r}_${c}`;
          const cx = offsetX + c*cellSize + cellSize/2;
          const cy = offsetY + r*cellSize + cellSize/2;
          
          const ownerIdx = boxes[key];
          if(ownerIdx !== undefined) {
            // Draw Box Texture Image
            const texKey = `p${ownerIdx}_tex`;
            // Add image with slight padding (0.9 scale)
            const img = this.add.image(cx, cy, texKey).setOrigin(0.5, 0.5);
            
            // Scale image to fit the box
            const scaleX = (cellSize - 2) / img.width;
            const scaleY = (cellSize - 2) / img.height;
            img.setScale(scaleX, scaleY);
            
            this.boxImages.push(img);
            
            if(roomData.config.mode === 'lucky' && specials[key]) {
                let icon = '';
                if(specials[key] === 'bonus') icon = 'â­';
                if(specials[key] === 'boom') icon = 'ðŸ’£';
                // Add Shadow behind icon for readability
                const txt = this.add.text(cx, cy, icon, { fontSize: `${cellSize/2}px`, stroke: '#000', strokeThickness: 4 }).setOrigin(0.5);
                this.specialIcons.push(txt);
            }
          }
        }
      }

      // Draw Grid Lines (On top of images)
      for(let r=0; r<=rows; r++) for(let c=0; c<cols; c++) {
        const id = `h_${r}_${c}`; const x = offsetX + c*cellSize; const y = offsetY + r*cellSize;
        this.drawEdge(id, x, y, x+cellSize, y, lineThick, true, cellSize);
      }
      for(let r=0; r<rows; r++) for(let c=0; c<=cols; c++) {
        const id = `v_${r}_${c}`; const x = offsetX + c*cellSize; const y = offsetY + r*cellSize;
        this.drawEdge(id, x, y, x, y+cellSize, lineThick, false, cellSize);
      }
      
      this.graphics.fillStyle(0x333333, 1);
      for(let r=0; r<=rows; r++) for(let c=0; c<=cols; c++) this.graphics.fillCircle(offsetX + c*cellSize, offsetY + r*cellSize, dotRadius);
    }

    drawEdge(id, x1, y1, x2, y2, thick, isHoriz, cellSize) {
      const taken = roomData.edges && roomData.edges[id];
      if(taken) {
        const pc = PLAYER_CONFIG[taken.cIdx];
        this.graphics.lineStyle(thick, pc.hex, 1);
        this.graphics.beginPath(); this.graphics.moveTo(x1, y1); this.graphics.lineTo(x2, y2); this.graphics.strokePath();
      } else {
        const cx = (x1+x2)/2; const cy = (y1+y2)/2;
        const w = isHoriz ? cellSize : thick*6; const h = isHoriz ? thick*6 : cellSize;
        const zone = this.add.rectangle(cx, cy, w, h, 0xffffff, 0.0001).setInteractive({cursor:'pointer'});
        zone.on('pointerdown', () => attemptClaim(id));
        this.clickZones.push(zone);
        this.graphics.lineStyle(1, 0x555555, 0.3); // Darker guide lines for light bg
        this.graphics.beginPath(); this.graphics.moveTo(x1, y1); this.graphics.lineTo(x2, y2); this.graphics.strokePath();
      }
    }
  }

  function attemptClaim(edgeId) {
    if(!roomData || roomData.state !== 'playing' || roomData.dice.rem <= 0) return;
    if(isRollingAnim) return; 
    const turnUid = roomData.turnOrder[roomData.turnIndex];
    if(turnUid !== myUid) return;

    db.ref(`rooms/${currentRoom}`).transaction(room => {
      if(!room || room.state !== 'playing' || room.dice.rem <= 0) return room;
      if(room.turnOrder[room.turnIndex] !== myUid) return;
      if(room.edges && room.edges[edgeId]) return;

      if(!room.edges) room.edges = {};
      const pColorIdx = room.players[myUid].colorIdx;
      room.edges[edgeId] = { cIdx: pColorIdx };
      room.dice.rem--;
      
      if(!room.boxes) room.boxes = {};
      let boxesMade = 0;
      let hitBoom = false; 
      let isLucky = false;
      
      const check = (r, c) => {
        if(r<0 || c<0 || r>=room.config.rows || c>=room.config.cols) return;
        if(room.boxes[`${r}_${c}`] !== undefined) return;
        
        const e = room.edges;
        if(e[`h_${r}_${c}`] && e[`h_${r+1}_${c}`] && e[`v_${r}_${c}`] && e[`v_${r}_${c+1}`]) {
          room.boxes[`${r}_${c}`] = pColorIdx;
          room.filledBoxes++;
          boxesMade++;

          let points = 1;
          const bKey = `${r}_${c}`;
          if(room.config.mode === 'lucky' && room.specialBoxes) {
             if(room.specialBoxes[bKey] === 'bonus') {
                points = 3;
                isLucky = true;
             } else if(room.specialBoxes[bKey] === 'boom') {
                hitBoom = true;
             }
          }
          room.players[myUid].score += points;
        }
      };

      const parts = edgeId.split('_');
      const r = parseInt(parts[1]); const c = parseInt(parts[2]);
      if(parts[0] === 'h') { check(r, c); check(r-1, c); }
      else { check(r, c); check(r, c-1); }

      if(room.filledBoxes >= room.totalBoxes) {
        room.state = 'finished';
        room.dice.rem = 0;
      }
      else {
        if(hitBoom) {
             room.dice.rem = 0;
             room.turnIndex = (room.turnIndex + 1) % room.turnOrder.length;
        } else if(room.dice.rem === 0) {
             room.turnIndex = (room.turnIndex + 1) % room.turnOrder.length;
        }
      }
      room.lastActive = Date.now();
      
      let sType = 'line';
      if(hitBoom) sType = 'boom';
      else if(isLucky) sType = 'lucky';
      return { ...room, soundTrigger: sType }; 
      
    }).then((res) => {
        if(res.committed) {
             const s = res.snapshot.val().soundTrigger;
             if(s === 'boom') sndBoom.play();
             else if(s === 'lucky') sndLucky.play();
             else sndLine.play();
        }
    });
  }
  </script>
</body>
</html>
